# -*- coding: utf-8 -*-
"""ASA_Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/117tNmGMiCm5n61RNroIOv9OHNMf6PMu7
"""

import math
from math import sin
from math import cos
from math import pow
import numpy as np
import pandas as pd
from google.colab import drive

"""# Assigning dataset to data

"""

data_node=pd.read_csv('/content/Copy of ASA_PROJECT-2 - Nodes (2).csv')
data_mem=pd.read_csv('/content/Copy of ASA_PROJECT-2 - Member (2).csv')

"""# Function of Transformation Matrix"""

def Transformation(angle ):          ## angle in degree
  angle= angle*(math.pi)/(180)       ## in this section angle are in radian
  c=round(cos(angle),2)
  s=round(sin(angle),2)
  T=[[c,-s,  0  ,   0  ,  0  ,  0],
      [s,c,  0  ,   0,    0  ,  0],
      [0,0,  1  ,   0,    0,    0],
      [0,0, 0  ,c,-s,    0],
      [0,0,  0  ,s,c,    0],
      [0,0,0,   0,    0,    1]
     ]

  return T

"""# Function of Stiffness Matrix"""

def K_function(A,E,I,L):

  K=[[  (A*E/L)         ,            0        ,     0            ,     (-A*E/L)     ,     0                 ,      0                ],
     [  0               ,   (12*E*I/pow(L,3)) , (6*E*I/pow(L,2)) ,                  0,    (-12*E*I/pow(L,3)), (6*E*I/pow(L,2))      ],
     [  0        ,    (6*E*I/(pow(L,2))),   (4*E*I/(L))       ,0,(-6*E*I/(pow(L,2)))    ,(2*E*I/(L))                    ],
    [              (-A*E/L),0 , 0 , (A*E/L),0,0                            ],
     [                          0 ,(-12*E*I/pow(L,3)), (-6*E*I/pow(L,2)) ,0,    (12*E*I/pow(L,3)), (-6*E*I/pow(L,2))           ],
     [                   0,(6*E*I/(pow(L,2))),   (2*E*I/(L))       ,0,(-6*E*I/(pow(L,2)))    ,(4*E*I/(L))                   ]]

  return K

"""# Assigning No of Nodes and No of Member"""

no_nodes=len(data_node.index)  #### No of nodes and member
no_mem=len(data_mem.index)

"""# Creating array of (global forces )fg , (fixed forces) ffg ,( global stiffness matrix)kga and (Deflection)dg_ind"""

fg=np.zeros((3*no_nodes,1))
ffg=np.zeros((3*no_nodes,1))
kga=np.zeros((3*no_nodes,3*no_nodes))
dg_ind=np.zeros((3*no_nodes,1))

"""# Assigning Value to fg from dataset"""

k=0
for i in range(no_nodes):

    fg[k+0]=data_node['Fx'][i]
    fg[k+1]=data_node['Fy'][i]
    fg[k+2]=data_node['Mz'][i]
    k+=3

print(fg)

"""# Calculating Member dimension in {member number:[distance , angle], } formate and member distance (=[]) and member angle (=[])"""

mem_dim={}
mem_dis=[]
mem_ang=[]
for i in range(no_mem):
  n1=data_mem['Node_1'][i]
  n2=data_mem['Node_2'][i]


  x1=data_node['X'][n1-1]
  y1=data_node['Y'][n1-1]
  p1=[x1,y1]

  x2=data_node['X'][n2-1]
  y2=data_node['Y'][n2-1]
  p2=[x2,y2]
  theta=math.atan((y2-y1)/(x2-x1))          ## theta in radian
  theta=theta*180/(math.pi)    ## theta in degree
  # temp1=str(i+1)
  mem_dim[i+1]=[math.dist(p1,p2),theta]
  mem_dis.append(math.dist(p1,p2))
  mem_ang.append(theta)

"""# Calculating fixed force in each memeber in fixed_mem=[]"""

fixed_mem=[[0] for i in range(no_mem)]

fixed_mem=[[0] for i in range(no_mem)]
# print(fixed_mem)
for i in range(no_mem):
  count=0
  a=data_mem['a'][i]
  b=data_mem['b'][i]
  dist=mem_dis[i]
  p=data_mem['P'][i]
  α=data_mem['c'][i]+data_mem['d'][i]/2
  β=data_mem['e'][i]+data_mem['d'][i]/2
  d=data_mem['d'][i]
  w1=data_mem['w1'][i]
  w2=data_mem['w2'][i]

  if(data_mem['P'][i]!=0):
    H_ff_left=0;
    # temp1=pow((data_mem['b'][i]),2)
    # temp3=mem_dim[i][0]
    # temp2=pow(temp3,2)
    M_ff_left=(-1)*(p)*(a)*(pow((b),2))/(pow(dist,2))
    H_ff_right=0
    M_ff_right=p*b*(pow(a,2))/(pow(dist,2))
    const=(M_ff_left+M_ff_right)/dist
    V_ff_left=(-p*b/dist)+const
    V_ff_right=(-p*a/dist)+const
    count=1


    fixed_mem[i]=[[H_ff_left],[V_ff_left],[M_ff_left],[H_ff_right],[V_ff_right],[M_ff_right]]

  elif(data_mem['P'][i]==0):
    fixed_mem[i]=[[0],[0],[0],[0],[0],[0]]




  if (w1!=0  or  w2!=0):

    if(count!=1):
      if(w1==w2):
             H_ff_left=0

             M_ff_left=(-1)*w1*d*(α*β*β+(α-2*β)*d*d/12)/(dist*dist)
             M_ff_right=w1*d*(α*α*β+(β-2*α)*d*d/12)/(dist*dist)
             const=(M_ff_left+M_ff_right)/dist
             H_ff_right=0
             V_ff_left=((-1)*w1*d*β/dist)+const
             V_ff_right=(w1*d*α/dist)-const
             fixed_mem[i]=[[H_ff_left],[V_ff_left],[M_ff_left],[H_ff_right],[V_ff_right],[M_ff_right]]
      elif(d==mem_dis[i]):
             H_ff_left=0
             M_ff_left=(-1)*(3*w1+2*w2)*mem_dis[i]*mem_dis[i]/60
             M_ff_right=(2*w1+3*w2)*mem_dis[i]*mem_dis[i]/60
             const=(M_ff_left+M_ff_right)/dist
             H_ff_right=0
             if(w2>w1):
                  V_ff_left=((w2-w1)*mem_dis[i]/6)+(w1*mem_dis[i]/2)+const
                  V_ff_right=(2*(w2-w1)*mem_dis[i]/6)+(w1*mem_dis[i]/2)-const
             else:
                  V_ff_left=((w1-w2)*mem_dis[i]/6)+(w2*mem_dis[i]/2)+const
                  V_ff_right=(2*(w1-w2)*mem_dis[i]/6)+(w2*mem_dis[i]/2)-const
             fixed_mem[i]=[[H_ff_left],[V_ff_left],[M_ff_left],[H_ff_right],[V_ff_right],[M_ff_right]]

    else:
        if(w1==w2):
             H_ff_left=0

             M_ff_left=(-1)*w1*d*(α*β*β+(α-2*β)*d*d/12)/(dist*dist)
             M_ff_right=w1*d*(α*α*β+(β-2*α)*d*d/12)/(dist*dist)
             const=(M_ff_left+M_ff_right)/dist
             H_ff_right=0
             V_ff_left=((-1)*w1*d*β/dist)+const
             V_ff_right=(w1*d*α/dist)-const
             fixed_mem[i]=[[H_ff_left+fixed_mem[i][0]],[V_ff_left+fixed_mem[i][1]],[M_ff_left+fixed_mem[i][2]],[H_ff_right+fixed_mem[i][3]],[V_ff_right+fixed_mem[i][4]],[M_ff_right+fixed_mem[i][5]]]

        elif(d==mem_dis[i]):
             H_ff_left=0
             M_ff_left=(-1)*(3*w1+2*w2)*mem_dis[i]*mem_dis[i]/60
             M_ff_right=(2*w1+3*w2)*mem_dis[i]*mem_dis[i]/60
             const=(M_ff_left+M_ff_right)/dist
             H_ff_right=0
             if(w2>w1):
                  V_ff_left=((w2-w1)*mem_dis[i]/6)+(w1*mem_dis[i]/2)+const
                  V_ff_right=(2*(w2-w1)*mem_dis[i]/6)+(w1*mem_dis[i]/2)-const
             else:
                  V_ff_left=((w1-w2)*mem_dis[i]/6)+(w2*mem_dis[i]/2)+const
                  V_ff_right=(2*(w1-w2)*mem_dis[i]/6)+(w2*mem_dis[i]/2)-const
             fixed_mem[i]=[[H_ff_left+fixed_mem[i][0]],[V_ff_left+fixed_mem[i][1]],[M_ff_left+fixed_mem[i][2]],[H_ff_right+fixed_mem[i][3]],[V_ff_right+fixed_mem[i][4]],[M_ff_right+fixed_mem[i][5]]]

"""# Calculating global matrix of fixed force"""

def global_merge(mat,mem_ang,no_mem,no_nodes):
    mat2=[[0] for i in range(3*no_nodes)]
    l=0


    for i in range(no_mem):
      if(mem_ang[i]!=0):
        mat[i]=np.dot(Transformation(mem_ang[i]) , mat[i])

    # print(mat)

    for j in range(len(mat)) :
       for k in range(len(mat[0])):
               temp1=j*3+k


               if(k<3 and j<1):
                 mat2[temp1][0]=mat[j][k][0]

               elif(k>=3 and  j<(no_mem-1) ):
                 mat2[temp1][0]=mat[j][k][0]+mat[j+1][k-3][0]

               elif (k>=3 and  j==(no_mem-1)):
                 mat2[temp1][0]=mat[j][k][0]
               else:
                  mat2[temp1][0]=mat[j][k][0]

    return mat2


ffg_global=global_merge(fixed_mem,mem_ang,no_mem,no_nodes)

"""# Calculating k local using data set value"""

kl=[]
for i in range(no_mem):
            kl.append(K_function(data_mem['A'][i],data_mem['Modulus_of_elasticity'][i],data_mem['I'][i],mem_dis[i]))

kl

"""# Code for transpose Matrix"""

def transpose(A):
      row=len(A)
      col=len(A[0])

      result=[[0 for i in range( row)] for j in range(col)]
      for i in range(len(A)):
        # iterate through columns
        for j in range(len(A[0])):
            result[j][i] = A[i][j]

      return result

"""# Calculating Global stifness matrix of each member"""

kg=[[0] for i in range(no_mem) ]
# print(kg)
for i in range(no_mem):
  if(mem_ang[i]!=0):
     t=Transformation(mem_ang[i])
     kl_temp=np.dot(kl[i],transpose(t))
     kg[i]=np.dot(t,kl_temp)

  else :
    kg[i]=  kl[i]

"""# Calculating full stiffness matrix"""

def merge_arr(arr):
    num_arr = len(arr)
    for i in range(1,num_arr):
        assert(arr[i].shape[0]==arr[i-1].shape[0])
    n = arr[0].shape[0]
    sz = n+(num_arr-1)*(n//2)
    C = np.zeros((sz,sz))

    s = 0
    e = n
    for i in range(num_arr):
        C[s:e,s:e]+=arr[i]
        s += (n//2)
        e += (n//2)
    return C
A = np.array([[1,2],[3,4]])
B = np.array([[5,6],[7,8]])
C = np.array([[9,10],[11,12]])
kg_full = merge_arr(np.array(kg))

"""# Assigning deflection  Value to dg_ind from dataset and finding unknown"""

k=0
for i in range(no_nodes):

    dg_ind[k+0]=data_node['u_x'][i]

    dg_ind[k+1]=data_node['v_y'][i]

    dg_ind[k+2]=data_node['th_z'][i]
    k+=3


no_unknown_d=0

for i in range(len(dg_ind)):
       if(dg_ind[i][0]==1):
             no_unknown_d+=1

"""# Calculating temperary deflection and temperary stiffness matrix to calculate deflection"""

temp_kg=kg_full.copy()

temp_kg_short=[[0 for i in range(no_unknown_d)] for j in range(no_unknown_d)]

count1=0
count2=0
prev=-8
random=0

for i in range(len(temp_kg)):
  count2=0
  for j in range(len(temp_kg[0])):
    if(dg_ind[i][0]==1 and dg_ind[j][0]==1 ):
      if(random==0):
        prev=i
        random=1
      if(i==prev):
        temp_kg_short[count1][count2]=temp_kg[i][j]
        count2+=1
      else:
        count1+=1
        prev=i
        count2=0
        temp_kg_short[count1][count2]=temp_kg[i][j]
        count2+=1

"""# Calculating force by =Fg-Ffg"""

force=[[0] for i in range(3*no_nodes)]

for i in range(3*no_nodes):
  force[i][0]=fg[i][0]-ffg_global[i][0]

print(force)

"""# Calculate short force matric to calculate deflection"""

count1=0
temp_force=[[0] for i in range(no_unknown_d)]
for i in range(len(force)):
  if(dg_ind[i][0]==1):
    temp_force[count1][0]=force[i][0]
    count1+=1

"""# Calculating final deflection"""

deflection=np.dot(np.linalg.inv(temp_kg_short),temp_force )

resultant_force=[[0] for i in range(3*no_nodes)]
resultant_d=[[0] for i in range(3*no_nodes)]
c=0
for i in range(3*no_nodes):
  if(dg_ind[i][0]==1):
    resultant_d[i][0]=deflection[c][0]
    c+=1
  else:
    resultant_d[i][0]=dg_ind[i][0]

"""# Calculating Final force on each node"""

resultant_k_d=np.dot(kg_full,resultant_d)
resultant_force=[[0] for i in range(3*no_nodes)]

resultant_k_d
for i in range(3*no_nodes):
  resultant_force[i][0]=round(ffg_global[i][0]+resultant_k_d[i][0]-fg[i][0],4)

resultant_force

"""# Summary Of calculation"""

print("Distance  and Angle of Each Member\n")
for i in range(len(mem_dis)):
  print("Member: ",i+1," Distance: ",mem_dis[i]," Angle: ",mem_ang[i])
print("\n")

for i in range(no_mem):
  print("Fixed Force and Moment",i+1," is : ")
  print(fixed_mem[i])
  print("\n")
for i in range(no_mem):
  print("Stiffness matrix for member",i+1," is : ")
  print(kl[i])
  print("\n")


print("\n")


# print(" GLOBAL STIFFNESS MATRIX , GLOBAL FFg , DEFLECTION ,Final Force ")
print("GLOBAL STIFFNESS MATRIX \n",kg_full)
print("\n")

print("GLOBAL FFg \n",ffg_global)
print("\n")
print("final displacement \n",resultant_d)
print("\n")
print("Final node Force \n",resultant_force)
print("\n")